

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>SOF Driver Architecture &mdash; SOF Project 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/zc.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/zc.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/common.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/css/sof.css" type="text/css" />

  
  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
  

  
  

  

  
  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
  <script type="text/javascript" src="../../../_static/js/zcaniot.js"></script>

    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Third Party Features User Guides" href="../third_party/index.html" />
    <link rel="prev" title="SOF Linux Driver" href="../index.html" />
  <link rel="shortcut icon" href="../../../_static/images/favicon.ico"/>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> SOF Project
          

          
            
            <img src="../../../_static/logo_sof_white_200w.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div id="searchbox" role="search">
  <div class="searchformwrapper">
    <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
  </div>
</div>
<script>$('#searchbox').show(0);</script>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference external" href="https://sofproject.org">SOF project website</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction/index.html">Introduction to the SOF Project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/index.html">Getting Started Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../architectures/index.html">Supported Architectures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../platforms/index.html">Platforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../algos/index.html">Algorithms</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Developer Guides</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../firmware/index.html">Firmware</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../unit_tests.html">Unit Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../xtrun/index.html">Xtensa Simulator (xt-run)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../topology/topology.html">SOF Topology</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../uuid/index.html">UUID Usage in SOF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../debugability/index.html">Debugability</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../tuning/sof-ctl.html">Runtime Tuning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rimage/index.html">Rimage</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">SOF Linux Driver</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">SOF Driver Architecture</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#overview">Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#driver-probe">Driver Probe</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sof-platform-driver">SOF Platform Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ipc-processing">IPC Processing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pcm-driver">PCM Driver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#power-management">Power Management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#intel-drivers">Intel Drivers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#support-for-high-definition-audio-hd-audio">Support for High Definition Audio (HD-Audio)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kernel-configuration-kconfig">Kernel Configuration/Kconfig</a></li>
<li class="toctree-l4"><a class="reference internal" href="#debug-options">Debug Options</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../third_party/index.html">Third Party Features User Guides</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../virtualization/virtualization.html">SOF VirtIO design</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../virtualization/running.html">Run SOF VirtIO</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../fuzzing/index.html">Fuzzing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../testbench/index.html">Testbench</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../index.html#technical-notes">Technical Notes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute/index.html">Contributing to the Project</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tsc/index.html">Technical Steering Committee (TSC)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maintainers/index.html">SOF admin, maintainers and code owners</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../presentations/index.html">Presentations</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SOF Project</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Developer Guides</a> &raquo;</li>
        
          <li><a href="../index.html">SOF Linux Driver</a> &raquo;</li>
        
      <li>SOF Driver Architecture</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../../_sources/developer_guides/linux_driver/architecture/sof_driver_arch.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="sof-driver-architecture">
<span id="sof-driver-arch"></span><h1>SOF Driver Architecture<a class="headerlink" href="#sof-driver-architecture" title="Permalink to this headline">Â¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#overview" id="id3">Overview</a></p></li>
<li><p><a class="reference internal" href="#driver-probe" id="id4">Driver Probe</a></p></li>
<li><p><a class="reference internal" href="#sof-platform-driver" id="id5">SOF Platform Driver</a></p></li>
<li><p><a class="reference internal" href="#ipc-processing" id="id6">IPC Processing</a></p></li>
<li><p><a class="reference internal" href="#pcm-driver" id="id7">PCM Driver</a></p></li>
<li><p><a class="reference internal" href="#power-management" id="id8">Power Management</a></p></li>
<li><p><a class="reference internal" href="#intel-drivers" id="id9">Intel Drivers</a></p></li>
<li><p><a class="reference internal" href="#support-for-high-definition-audio-hd-audio" id="id10">Support for High Definition Audio (HD-Audio)</a></p></li>
<li><p><a class="reference internal" href="#kernel-configuration-kconfig" id="id11">Kernel Configuration/Kconfig</a></p></li>
<li><p><a class="reference internal" href="#debug-options" id="id12">Debug Options</a></p></li>
</ul>
</div>
<div class="section" id="overview">
<h2><a class="toc-backref" href="#id3">Overview</a><a class="headerlink" href="#overview" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="audio-driver-architecture">
<h3>Audio Driver Architecture<a class="headerlink" href="#audio-driver-architecture" title="Permalink to this headline">Â¶</a></h3>
<p>The Sound Open Firmware (SOF)-based audio driver stack consists of an architecture-independent SOF driver core, an SOF DSP driver for Intel High Definition Audio (HD-Audio) platforms, an ALSA System-on-Chip (ASoC)-compliant audio codec driver, and a hardware-specific machine driver.</p>
<img alt="../../../_images/sof-driver-arch-1.png" src="../../../_images/sof-driver-arch-1.png" />
</div>
<div class="section" id="sound-open-firmware">
<h3>Sound Open Firmware<a class="headerlink" href="#sound-open-firmware" title="Permalink to this headline">Â¶</a></h3>
<p>Sound Open Firmware (SOF) is an open source audio Digital Signal Processing (DSP) firmware infrastructure and SDK. SOF provides infrastructure, real-time control pieces, and audio drivers. A generic SOF subsystem is implemented in Linux as a subsystem of ALSA ASoC.</p>
<img alt="../../../_images/sof-driver-arch-2.png" src="../../../_images/sof-driver-arch-2.png" />
</div>
<div class="section" id="alsa-and-asoc">
<h3>ALSA and ASoC<a class="headerlink" href="#alsa-and-asoc" title="Permalink to this headline">Â¶</a></h3>
<p>The Advanced Linux Sound Architecture <a class="reference external" href="https://www.alsa-project.org/wiki/Main_Page">(ALSA)</a> provides audio and MIDI functionality to the Linux operating system. The ALSA System-on-Chip <a class="reference external" href="https://alsa-project.org/wiki/ASoC">(ASoC)</a> is a subsystem of ALSA. ASoC provides a modular architecture to share audio codec drivers across different SoC implementations, unify the controls provided to applications, and provide a common infrastructure to manage SoC audio component power and clocks.</p>
</div>
<div class="section" id="related-alsa-drivers">
<h3>Related ALSA Drivers<a class="headerlink" href="#related-alsa-drivers" title="Permalink to this headline">Â¶</a></h3>
<p>The upstream Linux kernel has a few drivers that are related to the SOF-based audio driver stack described in this document. These drivers include the Intel AZX HD Audio driver (<code class="docutils literal notranslate"><span class="pre">linux/sound/pci/hda</span></code>) and the Intel SST Audio driver (<code class="docutils literal notranslate"><span class="pre">linux/sound/soc/intel/</span></code>).</p>
<p>The AZX driver is intended to be used with Intel HD Audio PCI hardware when the Audio DSP is disabled (e.g. BIOS configuration). The AZX driver should be used instead of SOF when the DSP is not used.</p>
<p>The SST Audio implements an ASoC-compliant driver for Intel HD Audio hardware, utilizing the Intel SST firmware. SST is primarily used with older generations of Intel processors for which SOF firmware support is not available. The SST driver and firmware should be used when the DSP is enabled and SOF firmware is not available for the platform.</p>
</div>
</div>
<div class="section" id="driver-probe">
<h2><a class="toc-backref" href="#id4">Driver Probe</a><a class="headerlink" href="#driver-probe" title="Permalink to this headline">Â¶</a></h2>
<p>The probe callback in the SOF PCI/APCI driver is responsible for allocating the platform data that is used to store the machine information including the PCI device ID, name, and the ACPI mach description. For Intel platforms, it uses the ACPI matching tables to determine the correct machine driver to load. The probe callback also sets up the SOF platform driver, initializes the Inter-Process Communication (IPC) to communicate with the DSP, and registers the SOF PCM component driver and the machine driver. Upon completion, it enables the runtime power management for the platform, if supported.</p>
</div>
<div class="section" id="sof-platform-driver">
<h2><a class="toc-backref" href="#id5">SOF Platform Driver</a><a class="headerlink" href="#sof-platform-driver" title="Permalink to this headline">Â¶</a></h2>
<p>The SOF platform driver is a platform-specific driver that abstracts the low-level platform DSP hardware into a common generic API that is used by the upper layers. This includes code that will initialize the DSP and boot the firmware. The platform driver is responsible for setting up platform-specific ops for the device. The mandatory and optional platform ops are defined in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_sof_dsp_ops</span></code>. It also describes the chip info the DUT by populating the <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">sof_intel_dsp_desc</span></code> fields necessary for DSP initialization.</p>
<div class="section" id="platform-driver-probe">
<h3>Platform Driver Probe<a class="headerlink" href="#platform-driver-probe" title="Permalink to this headline">Â¶</a></h3>
<p>The SOF platform driver detects the presence of a DSP in the platform by checking the PCI <code class="docutils literal notranslate"><span class="pre">class/sub-class/prog-id</span></code> information. It sets up the platform devices (ex: HDA device, dmic device), the DSP Base Address Registers, and initializes the streams and the interrupt vectors. Finally, it initializes the DSP capabilities and enables the DSP processing pipe capability interrupts.</p>
</div>
<div class="section" id="firmware-loading-and-booting">
<h3>Firmware Loading and Booting<a class="headerlink" href="#firmware-loading-and-booting" title="Permalink to this headline">Â¶</a></h3>
<p>On SKL+ platforms, firmware loading is performed using a dedicated DMA for code loading which is responsible for copying the FW into DSP memory. The DSP cores are powered up in a predetermined sequence and the host driver waits for the appropriate ROM init status to be written into the ROM status register to indicate initialization. This step is attempted a few times until the ROM status registers returns the successful ROM init status. Upon successful completion, the host driver triggers the code loader DMA to start copying the FW into DSP memory and boot it while waiting for the notification from the DSP. When the FW has successfully booted, the DSP sends the firmware-ready IPC message to notify the host. Further details are provided in <strong>IPC Processing</strong>, below.</p>
</div>
</div>
<div class="section" id="ipc-processing">
<h2><a class="toc-backref" href="#id6">IPC Processing</a><a class="headerlink" href="#ipc-processing" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="introduction">
<h3>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">Â¶</a></h3>
<p>The SOF Audio DSP firmware uses IPC to communicate with the host. IPC is also used by the preinstalled DSP ROM, so it is used at least to load and start an SOF image. During that phase, the host communicates with the DSP ROM. Once ROM initialization is complete and the SOF FW has booted, the consequent IPC is performed with the firmware.</p>
<p>IPC is bi-directional; messages can be initiated by the host and then acknowledged by the DSP. Similarly, they can be initiated by the DSP and acknowledged by the host. To indicate the direction of the communication, terms <strong>initiator</strong> and <strong>target</strong> are used.</p>
<p>After SOF completes its boot process, it informs the host that it is ready for operation. Prior to receiving this message from the DSP, the mailbox offsets are not configured. Therefore, the message is read out from the DSP-to-host mailbox configured in the PCI mailbox BAR. Once read out, the message is parsed to determine the exact layout of all the IPC mailbox buffers. After that, the host sends further IPC messages to perform DSP configuration and initialization.</p>
<p>At run-time, IPC is used for streaming control and buffer management, as well as for firmware traces.</p>
</div>
<div class="section" id="ipc-hardware-implementation">
<h3>IPC Hardware Implementation<a class="headerlink" href="#ipc-hardware-implementation" title="Permalink to this headline">Â¶</a></h3>
<p>On most systems, the DSP and the host CPUs can access the same memory, such as where the DSP is implemented as a PCI device on the host system. On other systems, the DSP is implemented as a stand-alone device, connected to the host by a serial bus such as SPI.</p>
</div>
<div class="section" id="intel-ipc">
<h3>Intel IPC<a class="headerlink" href="#intel-ipc" title="Permalink to this headline">Â¶</a></h3>
<p>At the hardware level, IPC support is implemented using a set of doorbell
registers and mailbox buffers. Details of the implementation can vary between
architectures. In general, sending an IPC message and replying to it involves
the following steps:</p>
<ol class="arabic simple">
<li><p>If the IPC message is supposed to contain a payload, which is almost always the case with SOF, the initiator first copies the payload to the respective mailbox buffer.</p></li>
<li><p>The initiator sets a BUSY bit in an initiator-side IPC register, which then sets a BUSY bit on the target side.</p></li>
<li><p>If configured, this can also generate an interrupt on the target side.</p></li>
<li><p>When the target completes processing the received message, it clears the BUSY bit on its own side. This is then reflected to the initiator side, where as a result the BUSY bit is cleared and the DONE bit is set.</p></li>
<li><p>Setting the DONE bit can also generate an interrupt on the initiator side.</p></li>
<li><p>The initiator processes the reply from the target and clears the DONE bit.</p></li>
</ol>
<p>SOF on both the host and the DSP serializes the sending of their IPC messages. Therefore, a new message cannot be initiated before the target has finished processing the previous one. However, both the host and the DSP can initiate their messages simultaneously. This cannot lead to a race because both the host and the DSP have separate target and initiator IPC registers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The IPCCTL register is common for target and initiator operations
and is used to mask and unmask BUSY and DONE interrupts. Therefore, in
theory, a race is possible where one context would try to mask or unmask
one of the bits (e.g. BUSY) while a different context, running on a
different core, would try to mask or unmask the other bit (DONE). This
can lead to inconsistent register contents. To avoid this, the software
has to make sure to lock the read-modify-write operations on the IPCCTL.</p>
</div>
</div>
<div class="section" id="spi">
<h3>SPI<a class="headerlink" href="#spi" title="Permalink to this headline">Â¶</a></h3>
<p>IPC messages have the same structure as in the PCI case, but they are sent and received over an SPI bus. The SPI transfer is always initiated by the SPI provider, which is the host. Therefore, the DSP cannot send asynchronous messages to the host using only the SPI bus. To overcome this limitation, an additional GPIO line is used by the DSP to trigger an interrupt on the host to request it to read out an IPC message. Support for such devices is still experimental in SOF. Details will be added later.</p>
</div>
<div class="section" id="imx-ipc">
<h3>iMX IPC<a class="headerlink" href="#imx-ipc" title="Permalink to this headline">Â¶</a></h3>
<p>Information on this subject matter is forthcoming.</p>
</div>
<div class="section" id="ipc-messages">
<h3>IPC Messages<a class="headerlink" href="#ipc-messages" title="Permalink to this headline">Â¶</a></h3>
<p>IPC messages are divided into several groups: global reply, topology, power management, component, stream, DAI, trace, and a separate âfirmware readyâ message. Multiple messages can also be grouped into a message that belong to a compound group. For all IPC message definitions, see <code class="docutils literal notranslate"><span class="pre">include/sound/sof/header.h</span></code>. Most messages are sent by the host to the DSP; only the following messages are sent by the DSP to the host:</p>
<ul class="simple">
<li><p>firmware ready: sent only once during initialization</p></li>
<li><p>trace: optional, contains firmware trace data</p></li>
<li><p>position update: only used if position data cannot be transferred in a memory window or if forced by the kernel configuration</p></li>
</ul>
</div>
</div>
<div class="section" id="pcm-driver">
<h2><a class="toc-backref" href="#id7">PCM Driver</a><a class="headerlink" href="#pcm-driver" title="Permalink to this headline">Â¶</a></h2>
<p>The SOF PCM driver creates ALSA PCMs, DAPM, and kcontrols based on the
<a class="reference internal" href="../../topology/topology.html#topology"><span class="std std-ref">SOF Topology</span></a> data loaded at runtime. The PCM driver also allocates
buffers for DMA and registers with runtime PM. It contains architecture-
and platform-generic code. The PCM driver implements the low-level
functions defined by the ALSA PCM middle layer in <code class="docutils literal notranslate"><span class="pre">struct</span>
<span class="pre">snd_pcm_ops</span></code>. These functions implement the platform-generic parts and
invoke platform-specific ops to access the hardware.</p>
<p>When the machine driver is probed and the sound card is registered, the SOF PCM component driver gets probed when the dai links in the sound card are bound to the card. The SOF PCM component probe callback loads the topology file for the DUT. The SOF topology defines the audio processing pipelines, FE DAIs, and the BE DAI configuration for the BE dai links defined in the machine driver. Therefore, it is important to make sure that the DAI link IDs for the BE DAIs are identical in the topology and the machine driver. A mismatch in the DAI links ID will cause the sound card registration to fail.</p>
<div class="section" id="topology-loading">
<h3>Topology Loading<a class="headerlink" href="#topology-loading" title="Permalink to this headline">Â¶</a></h3>
<p>The SOF PCM component probe invokes <code class="docutils literal notranslate"><span class="pre">snd_sof_load_topology()</span></code> to load the topology binary and triggers the parsing and loading of all the defined components. The topology operations pertinent to the loading/unloading of the various topology components are defined in <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_soc_tplg_ops</span></code> in <code class="docutils literal notranslate"><span class="pre">topology.c</span></code>. The topology parser invokes these callbacks to perform driver-specific loading operations for each component/widget. The load callback for each type of component in topology performs two main functions:</p>
<ol class="arabic simple">
<li><p>Parse the component specific tokens associated with the component and populate the IPC structure.</p></li>
<li><p>Send the IPC to the DSP to set up, configure, and link the components.</p></li>
</ol>
<p>The unload callback is responsible for freeing the memory associated with the component and remove it from the list of components. Currently, the SOF driver supports loading only one topology file during boot up. This might be extended in the future to support multiple topologies that can be dynamically loaded/unloaded at runtime.</p>
<p>The topology file also defines the IO callbacks for the kcontrols supported by the SOF topology, namely mixer, enum, and byte controls.</p>
<div class="section" id="kcontrol-io">
<h4>Kcontrol IO<a class="headerlink" href="#kcontrol-io" title="Permalink to this headline">Â¶</a></h4>
<p>The kcontrol IO callbacks are all defined in <code class="docutils literal notranslate"><span class="pre">control.c</span></code>. The three types of kcontrol supported by SOF are:</p>
<ol class="arabic simple">
<li><p>Volume: The volume kcontrol put callback is responsible for translating the user setting for volume level to the appropriate dB value and sending the IPC to the DSP. The get callback reads the volume dB value set in the DSP and determines the appropriate user space setting.</p></li>
<li><p>Enum: The enum put callback reads the user set value of the enum kcontrol and sends the IPC to the DSP to set the corresponding value in the FW. The get callback reads the enum value from the DSP and updates the user space setting.</p></li>
<li><p>Bytes: The byte control put callback is used for passing binary data from the user to the DSP FW. Depending on the size of the binary data being sent, the driver splits the data across multiple IPC messages. The FW is responsible for consolidating the data at the other end when the last segment of the data has been received from the host. The get callback gets the binary data from the DSP and passes it to the user space. As with the put callback, this is accomplished either in a single IPC or multiple IPCs, depending on the size of the binary data being read.</p></li>
</ol>
</div>
</div>
<div class="section" id="stream-management">
<h3>Stream Management<a class="headerlink" href="#stream-management" title="Permalink to this headline">Â¶</a></h3>
<p>The SOF PCM driver handles all stream control operations initiated by ALSA such as pcm open, close, hw_params, and trigger start/stop. It includes the code for the generic PCM operations while invoking the platform-specific callbacks to access the hardware.</p>
<div class="section" id="pcm-open-close">
<h4>PCM open/close<a class="headerlink" href="#pcm-open-close" title="Permalink to this headline">Â¶</a></h4>
<p>When a pcm is opened, the SOF pcm open <code class="docutils literal notranslate"><span class="pre">ioctl</span></code> assigns the stream for the host DMA and the stream is released when the pcm is closed.</p>
</div>
<div class="section" id="pcm-hw-params-free">
<h4>PCM HW Params/Free<a class="headerlink" href="#pcm-hw-params-free" title="Permalink to this headline">Â¶</a></h4>
<p>During the hw_params step, the SOF PCM driver performs the following operations:</p>
<ol class="arabic simple">
<li><p>Allocates audio buffer pages.</p></li>
<li><p>Invokes the platform-specific stream hw_params op. For SKL+ platforms, this involves decoupling host and link DMA engines, resetting the streams, setting up and programming the BDLs, and enabling the DMA interrupts.</p></li>
<li><p>Sends IPC to the FW to set up the stream params in the DSP.</p></li>
</ol>
<p>The PCM free <code class="docutils literal notranslate"><span class="pre">ioctl</span></code> undoes the operations performed during hw_params.</p>
</div>
<div class="section" id="pcm-trigger">
<h4>PCM Trigger<a class="headerlink" href="#pcm-trigger" title="Permalink to this headline">Â¶</a></h4>
<p>When the trigger <code class="docutils literal notranslate"><span class="pre">ioctl</span></code> is invoked, the SOF PCM driver invokes the platform-specific stream trigger operation and then sends the corresponding stream trigger IPC message to the DSP. The platform-specific stream trigger operation is responsible for starting/stopping the stream DMA, depending on the trigger command being invoked.</p>
</div>
<div class="section" id="pcm-prepare">
<h4>PCM Prepare<a class="headerlink" href="#pcm-prepare" title="Permalink to this headline">Â¶</a></h4>
<p>The SOF PCM driver does not advertise <code class="docutils literal notranslate"><span class="pre">SNDRV_PCM_INFO_RESUME</span></code> in the runtime configuration for pcm streams. This means that upon resuming from system suspend, the streams that were active prior to suspend will be restarted instead of being resumed. Therefore, when restarting the suspended streams, the hw_params needs to set up again before triggering them. The SOF driver utilizes the prepare <code class="docutils literal notranslate"><span class="pre">ioctl</span></code> that is invoked upon resuming to determine if the hw_params needs to set up again or not.</p>
</div>
</div>
</div>
<div class="section" id="power-management">
<h2><a class="toc-backref" href="#id8">Power Management</a><a class="headerlink" href="#power-management" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="id1">
<h3>Overview<a class="headerlink" href="#id1" title="Permalink to this headline">Â¶</a></h3>
<p>The SOF framework implements the standard Linux kernel power management interface for devices. The SOF core exports the following standard methods:</p>
<ul class="simple">
<li><p>snd_sof_runtime_suspend()</p></li>
<li><p>snd_sof_runtime_resume()</p></li>
<li><p>snd_sof_suspend()</p></li>
<li><p>snd_sof_resume()</p></li>
</ul>
<p>On Intel HDA platforms, the PCI device registered in <code class="docutils literal notranslate"><span class="pre">linux/sound/soc/sof/sof-pci-dev.c</span></code> uses the above exported symbols to fill the Linux PM struct <code class="docutils literal notranslate"><span class="pre">dev_pm_ops</span></code>.</p>
<p>SOF is configured to support both system sleep and runtime power management. In a typical configuration, the SOF device is runtime-suspended if no ALSA PCM streams are active and no ALSA mixer controls (kcontrols) are used by user space applications. Currently for Intel platforms, the only two power states supported for the DSP are D0 (DSP is on) and D3 (DSP is powered off).</p>
</div>
<div class="section" id="suspend-flow">
<h3>Suspend Flow<a class="headerlink" href="#suspend-flow" title="Permalink to this headline">Â¶</a></h3>
<ul class="simple">
<li><p>Firmware trace is released (if enabled).</p></li>
<li><p>Debugfs state is cached (if enabled, affects debugfs nodes linked to DSP memory that will lose its state in suspend).</p></li>
<li><p>Context-save IPC (SAVE_CTX) message is sent to firmware to notify the DSP of upcoming D3 entry.</p></li>
<li><p>DSP-specific suspend flow is run.</p>
<ul>
<li><p>On the Intel HDA; this involves logic to reset the HDA controller, disable IRQs, and power down the DSP cores.</p></li>
<li><p>Runtime and system suspend flows have their own code paths.</p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="resume-flow">
<h3>Resume Flow<a class="headerlink" href="#resume-flow" title="Permalink to this headline">Â¶</a></h3>
<ul class="simple">
<li><p>DSP specific resume flow.</p>
<ul>
<li><p>On Intel HDA, this involves logic to take the HDA controller out of reset, power up the DSP cores, and enable IRQs.</p></li>
<li><p>Runtime and system resume flows have their own code paths.</p></li>
</ul>
</li>
<li><p>Firmware boot</p></li>
<li><p>Firmware trace is re-enabled (if configured).</p></li>
<li><p>Existing PCM pipelines are restored to the firmware, using cached data maintained in the SOF driver (see sof_restore_pipelines()).</p></li>
<li><p>Kcontrol values are restored from the cached data.</p></li>
<li><p>Resume is completed by notifying the firmware with the Context Restored (CTX_RESTORE) IPC message.</p></li>
</ul>
</div>
<div class="section" id="interaction-with-codec-drivers">
<h3>Interaction with Codec Drivers<a class="headerlink" href="#interaction-with-codec-drivers" title="Permalink to this headline">Â¶</a></h3>
<p>The audio codec drivers (compliant with the ALSA ASoC framework) are created as children of the SOF platform device in the Linux device hierarchy. While the codec drivers (located typically under <code class="docutils literal notranslate"><span class="pre">linux/sound/soc/codecs/</span></code>) manage their power flows independently, the parent-child relationship guarantees ordering between SOF platform device and the codecs. For suspend, the codecs are suspended before the SOF platform device and, similarly for resume, the platform driver is resumed first and then the codec driver.</p>
</div>
</div>
<div class="section" id="intel-drivers">
<h2><a class="toc-backref" href="#id9">Intel Drivers</a><a class="headerlink" href="#intel-drivers" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="intel-hda-sof-dsp-platform-driver">
<h3>Intel HDA SOF DSP Platform Driver<a class="headerlink" href="#intel-hda-sof-dsp-platform-driver" title="Permalink to this headline">Â¶</a></h3>
<p>SOF implementation for Intel platforms is performed by the DSP Platform drivers. A platform driver implements the generic SOF <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">snd_sof_dsp_ops</span></code> interface, including functions such as doorbell, IPC messages send and receive, firmware load, and power up/down. The platform implements these methods for a given hardware target. The Intel platform drivers are located in the <code class="docutils literal notranslate"><span class="pre">linux/sound/soc/sof/intel/</span></code> folder of the Linux kernel tree.</p>
</div>
<div class="section" id="intel-hda-dsp-driver-for-cnl-cml-whl">
<h3>Intel HDA DSP Driver for CNL/CML/WHL<a class="headerlink" href="#intel-hda-dsp-driver-for-cnl-cml-whl" title="Permalink to this headline">Â¶</a></h3>
<p>The hardware interface for the Cannon Lake, Comet Lake, and Whiskey Lake platforms are defined in the <code class="docutils literal notranslate"><span class="pre">linux/sound/soc/sof/intel/cnl.c</span></code> file. For simplicity, all three platforms will be addressed with the CNL acronym in this section. This file defines the DSP ops required for initializing the SOF driver. Most of the DSP ops for the CNL are shared with the other Intel HDA platforms such as APL. The key changes in the CNL DSP driver are the doorbell registers and the corresponding IPC IRQ implementation.</p>
</div>
<div class="section" id="intel-machine-drivers">
<h3>Intel Machine Drivers<a class="headerlink" href="#intel-machine-drivers" title="Permalink to this headline">Â¶</a></h3>
<p>The ALSA SoC Layer (ASoC) includes machine drivers. A machine driver glues together various software components (e.g. drivers for codecs, platforms, and digital audio interfaces), describes the relationships between the components, and registers the result as an ALSA sound card to the kernel. A machine driver can be generic, handling a family of similar systems, or can be very specific, targeting a single product.</p>
<p>A set of machine drivers is included in the Linux kernel and provides support for a variety of systems with the Intel Audio DSP. These drivers are located in <code class="docutils literal notranslate"><span class="pre">linux/soc/intel/boards</span></code>. The generic SOF HD-Audio machine driver (<code class="docutils literal notranslate"><span class="pre">skl_hda_dsp_generic.c</span></code>) can handle any system that meets the following criteria:</p>
<ul class="simple">
<li><p>HDMI/DP codec in Intel Graphics</p></li>
<li><p>Optional: 1 external HDA codec</p></li>
<li><p>Optional: 1 to 4 digital microphones directly connected to PCH (not via codec)</p></li>
</ul>
<p>If the system has any I2S audio codecs or MIPI SoundWire codecs, the generic HD-Audio machine driver cannot be used and a dedicated machine driver is required instead.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some existing machine drivers were previously developed for Intel closed source audio firmware (SST firmware, IntelÂ® Smart Sound Technology). The SOF platform driver works with the existing machine drivers and requires no changes. The one big difference, though, is that the SOF PCM driver ignores the FE DAI links defined in the machine driver and overrides them with the ones defined in the SOF topology.</p>
</div>
</div>
</div>
<div class="section" id="support-for-high-definition-audio-hd-audio">
<h2><a class="toc-backref" href="#id10">Support for High Definition Audio (HD-Audio)</a><a class="headerlink" href="#support-for-high-definition-audio-hd-audio" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="generic-hd-audio-support">
<h3>Generic HD-Audio Support<a class="headerlink" href="#generic-hd-audio-support" title="Permalink to this headline">Â¶</a></h3>
<p>The Intel HD Audio controller is the standard audio host controller widely adopted in the PC platform; the industry standard Intel HD Audio driver software is available for Linux-based OSs. This driver is often referred to as the legacy HD-Audio driver. HDA DMA is used to transmit data between the host memory and the HD-A bus, and then to the external HDA codecs.</p>
<p>On Intelâs platforms after Skylake (SKL+ platforms), the HDA controller is converged with the Audio DSP, and the HDA DMA is split into two parts, the host DMA and the link DMA. The host DMA is used to transmit data between the host memory and DSP memory so data can be processed by DSP firmware. The link DMA is used to transmit data between the DSP memory and the <code class="docutils literal notranslate"><span class="pre">HDA/iDisp/I2S/SoundWire</span></code> bus (and then to the <code class="docutils literal notranslate"><span class="pre">HDA/HDMI/I2S/SoundWire</span></code> codecs). The SOF driver plus firmware can support this HDA DSP-converged architecture.</p>
<p>In the Linux ALSA framework, use of the audio DSP is optional. The common HDA library (hdac library, in <code class="docutils literal notranslate"><span class="pre">sound/hda/</span></code>) is designed for both legacy HDA and HDA via Audio DSP support. It implements the HDA framework-level support, including the HDA bus, the HDA controller, and the HDA stream management.</p>
<p>In SOF, the HDA driver (<code class="docutils literal notranslate"><span class="pre">sound/soc/sof/intel/hda*.c</span></code>) uses the hdac library to initialize the HDA bus and controller, probe codecs, and add SOF-specific stream management. Please note that HDA controller initialization and stream management are mandatory for Intel SKL+ platforms even if no HDA/HDMI-codec support is required, because the host DMA and stream control registers are part of HDA controller.</p>
<p>The Legacy HD-Audio driver and SOF driver can coexist in one Linux distribution. The <code class="docutils literal notranslate"><span class="pre">snd-intel-dspcfg</span></code> kernel driver implements logic to select the correct driver based on ACPI table contents and platform capabilities detected at runtime. For example, if no specific configuration is defined in ACPI tables and digital microphones are directly attached to the PCH (Intel Platform Control Hub), an audio DSP is required and thus the SOF driver is chosen automatically.</p>
</div>
<div class="section" id="hd-audio-codec-support">
<h3>HD-Audio Codec Support<a class="headerlink" href="#hd-audio-codec-support" title="Permalink to this headline">Â¶</a></h3>
<p>In ASoC, the HD-Audio codec is implemented in <code class="docutils literal notranslate"><span class="pre">hdac_hda.c</span></code> in the <code class="docutils literal notranslate"><span class="pre">soc/codec</span></code> directory. It reuses the legacy HD-Audio codec driver and implements the features required by ASoC, such as registering the audio codec component driver, dapm routes, and codec dai operators. Three dai links are supported: Analog, Digital, and Alt Analog codec dai. Since power management is implemented in the legacy hda codec driver, there is no PM function in this codec driver.</p>
</div>
<div class="section" id="display-audio-support">
<h3>Display Audio Support<a class="headerlink" href="#display-audio-support" title="Permalink to this headline">Â¶</a></h3>
<p>SOF also supports the Intel i915 audio codec driver. The Intel HDMI audio codec driver supports HDMI audio, Single Stream Transport (SST) Display Port (DP) audio, and Multi Stream Transport (MST) DP audio. It fully supports 3+ PCM playback streams; it does not support capture streams.</p>
<p>When an HDMI/DP display with audio support is connected, it is attached to a free ALSA PCM node from the pool of nodes reserved for HDMI. The status of HDMI/DP PCM connections is exposed via the ALSA mixer card controls <strong>HDMI/DP,pcm=X Jack</strong>, where X is the PCM device number. When a connection is detected, another ALSA mixer PCM control, <strong>name=âELDâ,device=X</strong>, describes the connected monitor. This data is formatted as ELD data (<strong>EDID Like Data</strong>, where EDID is Extended Display Identification Data), as defined in the <a class="reference external" href="https://www.intel.com/content/dam/www/public/us/en/documents/product-specifications/high-definition-audio-specification.pdf">HDA</a> specification.</p>
<p>Starting with Linux kernel version 5.5, HDMI/DP audio is implemented with an architecture that is similar to other HDA codecs. Implementation of the HDMI/DP codec is in <code class="docutils literal notranslate"><span class="pre">snd-hda-codec-hdmi</span></code> (<code class="docutils literal notranslate"><span class="pre">sound/pci/hda/patch_hdmi.c</span></code>).</p>
<p>In older versions of Linux, a dedicated codec driver was used (<code class="docutils literal notranslate"><span class="pre">sound/soc/codec/hdac_hdmi.c</span></code>) but is now deprecated.</p>
<div class="section" id="dependency-on-intel-graphics-driver-i915">
<h4>Dependency on Intel Graphics Driver (i915)<a class="headerlink" href="#dependency-on-intel-graphics-driver-i915" title="Permalink to this headline">Â¶</a></h4>
<p>The HDMI/DP audio codec is integrated in the graphics card. This means the SOF HDMI/DP audio codec driver directly depends on the Intel i915 graphic driver.</p>
<p>The graphics driver and the HDMI/DP audio codec driver use the âcomponentâ model to handle the upper communication between the graphics driver and the audio driver. The graphics driver is bound to the audio driver as a component. This interface is used to request power, clocks, get notifications of monitor connection changes, and to get access to auxiliary information about the monitor. The main structure that is used in the graphic and audio communication is <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">drm_audio_component</span></code>. Refer to <code class="docutils literal notranslate"><span class="pre">drm_audio_component.h</span></code> for more information on the structure.</p>
<p>The graphics card includes an Audio Power Domain which is dedicated to the audio power setting. Any audio operation on the HDMI/DP audio codec requires the Audio Power Domain to be turned on. After an operation, the audio driver should turn off the Audio Power Domain. The HDMI/DP audio codec clock domain is located in the graphic card. Whenever the audio sample rate/bit rate is changed, the audio driver requires the graphic driver to modify the clock setting correspondingly.</p>
</div>
<div class="section" id="audio-for-displayport-multi-stream-transport-dp-mst">
<h4>Audio for DisplayPort Multi-Stream Transport (DP-MST)<a class="headerlink" href="#audio-for-displayport-multi-stream-transport-dp-mst" title="Permalink to this headline">Â¶</a></h4>
<p>The Multi-Stream Transport (DP-MST) feature was first introduced in the DP 1.2 specification. It allows graphics to transfer multiple streams on a single connection. In a typical implementation, the multiplexed stream is terminated at a DP-MST hub which routes the individual streams into separate displays.</p>
<p>The SOF HDMI/DP audio codec driver handles DP-MST audio streams transparently, and a DP-MST is treated in a similar way as any HDMI or DP-SST stream.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>With Linux kernel versions 5.4 and older, the HDMI/DP implementation is using another codec driver and DP-MST interface to user-space is difference. With the old codec implementation, user-space software can determine the connection matrix between the monitors and the DP-MST port though <strong>Pin#n-Port#m Mux</strong> kcontrols in the alsamixer tool.</p>
</div>
</div>
</div>
</div>
<div class="section" id="kernel-configuration-kconfig">
<h2><a class="toc-backref" href="#id11">Kernel Configuration/Kconfig</a><a class="headerlink" href="#kernel-configuration-kconfig" title="Permalink to this headline">Â¶</a></h2>
<p>Refer to the <a class="reference external" href="https://github.com/thesofproject/kconfig/blob/master/README.md/">README</a> file of the SOF kconfig repository.</p>
</div>
<div class="section" id="debug-options">
<h2><a class="toc-backref" href="#id12">Debug Options</a><a class="headerlink" href="#debug-options" title="Permalink to this headline">Â¶</a></h2>
<p>SOF provides multiple options to enable developers to quickly bring up new platforms and debug errors/crashes that occur during audio test cases. The most notable ones are as below:</p>
<div class="section" id="nocodec-mode">
<h3>Nocodec Mode<a class="headerlink" href="#nocodec-mode" title="Permalink to this headline">Â¶</a></h3>
<p>The no-codec mode is specifically meant for speeding up the process of bringing up SOF on new platforms. This mode enables developers to quickly verify basic audio functionality on the available Digital Audio Interfaces (DAI) on the platform. This is also useful to rule out issues due to potential errors in the codec drivers.</p>
</div>
<div class="section" id="debugfs">
<h3>Debugfs<a class="headerlink" href="#debugfs" title="Permalink to this headline">Â¶</a></h3>
<p>SOF exposes several memory windows to the user space through the kernel debugfs filesystem. Developers can read or dump out the contents of these debugfs entries to infer the state of the DSP in case of a panic or a crash. Some of the most useful debugfs entries SOF exposes are mailbox, exception, and trace.</p>
</div>
<div class="section" id="firmware-tracing">
<h3>Firmware Tracing<a class="headerlink" href="#firmware-tracing" title="Permalink to this headline">Â¶</a></h3>
<p>The tracing feature in the SOF firmware allows the DSP to send trace messages to the host. This tracing feature fills in for the lack of a printf feature while executing firmware code on the DSP. The host configures and sets up the DMA buffer for receiving the trace messages from the DSP. Once the trace DMA triggers, the DSP periodically initiates a DMA transfer to copy over the trace messages to the host. These messages can then be parsed using the sof-logger utility which prints out the messages in chronological order.</p>
<p>More information is available in the firmware debuggability sections for <a class="reference internal" href="../../debugability/traces/index.html#dbg-traces"><span class="std std-ref">Traces</span></a> and <a class="reference internal" href="../../debugability/logger/index.html#dbg-logger"><span class="std std-ref">Logger</span></a>.</p>
</div>
<div class="section" id="ipc-flooding">
<h3>IPC Flooding<a class="headerlink" href="#ipc-flooding" title="Permalink to this headline">Â¶</a></h3>
<p>The IPC flooding feature is useful to determine the throughput when sending IPCs from the host to the DSP at a very high rate. It is also useful for exposing race conditions which might cause IPC timeouts to occur. Two available options allow the user to either flood the DSP with a specified number of IPCs or flood the DSP with IPCs for the specified duration.</p>
</div>
<div class="section" id="force-ipc-position">
<h3>Force IPC Position<a class="headerlink" href="#force-ipc-position" title="Permalink to this headline">Â¶</a></h3>
<p>Sending position update IPC from the firmware to the host is a generic method to generate period interrupts to meet the requirement from the ALSA IRQ mode (e.g. <code class="docutils literal notranslate"><span class="pre">snd_pcm_period_elapsed()</span></code>). On some HDA-integrated platforms (e.g. Intel SKL+ ones), this interrupt can be generated using the <a class="reference external" href="https://www.intel.com/content/dam/www/public/us/en/documents/product-specifications/high-definition-audio-specification.pdf">HDA</a> period IOC (interrupt on complete) and the real-time buffer pointers can be read back from the DPIB (DMA Pointer In Buffer). On these platforms, the position update IPC is only the fallback choice and is not used by default.</p>
<p>In order to debug issues with IOC/DPIB, the force IPC position kernel
debug config can be selected. On Intel SKL- platforms, the stream
position update IPC is used whether or not this option is selected.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../third_party/index.html" class="btn btn-neutral float-right" title="Third Party Features User Guides" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../index.html" class="btn btn-neutral" title="SOF Linux Driver" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">

<table>
<tr>
<td>
    <p>
        &copy; Copyright 2021, SOF Project..
      Last updated on May 10, 2022.

    </p>
</td>
<td id="zcanlogo">
  <a href="https://www.unisim-micro.com/"><img src="../../../_static/images/zcan.svg" border="0" style="position:static"/></a>
</td>
</tr>
</table>
  </div> 


</footer>
        </div>
      </div>

    </section>

  </div>
  
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> SOF Project</span>
       <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      
      <div class="rst-other-version zcansdk">
        <a href="../../../../zcansdk/index.html">ZCAN IOT SDK</a>
      </div>
      
      <div class="rst-other-version zcanxlib">
        <a href="../../../../zcanxlib/README.html">ZCAN Xlib</a>
      </div>
      
      <div class="rst-other-version zephyr">
        <a href="../../../../zephyr/index.html">Zephyr Project</a>
      </div>
      
      <div class="rst-other-version mcuboot">
        <a href="../../../../mcuboot/wrapper.html">MCUboot</a>
      </div>
      
      <div class="rst-other-version kconfig">
        <a href="../../../../kconfig/index.html">Kconfig Reference</a>
      </div>
    </div>
  </div>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>